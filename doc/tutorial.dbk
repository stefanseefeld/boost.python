<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" id="tutorial" rev:last-revision="$Date: 2016/08/05 20:23:25 $">
  <title>Boost.Python Tutorial</title>
  <articleinfo>
    <authorgroup>
    <author>
      <firstname>Joel</firstname> <surname>de Guzman</surname>
    </author>
    <author>
      <firstname>David</firstname> <surname>Abrahams</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2002</year> <year>2003</year> <year>2004</year> <year>2005</year> <holder>Joel
      de Guzman, David Abrahams</holder>
    </copyright>
    <legalnotice id="tutorial.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>
      </para>
    </legalnotice>
    <articlepurpose>
      Reflects C++ classes and functions into Python
    </articlepurpose>
    <articlecategory name="category:inter-language support"/>
  </articleinfo>
  <section id="tutorial.quickstart">
    <title><link linkend="tutorial.quickstart">QuickStart</link></title>
    <para>
      The Boost Python Library is a framework for interfacing Python and C++. It
      allows you to quickly and seamlessly expose C++ classes functions and objects
      to Python, and vice-versa, using no special tools -- just your C++ compiler.
      It is designed to wrap C++ interfaces non-intrusively, so that you should not
      have to change the C++ code at all in order to wrap it, making Boost.Python
      ideal for exposing 3rd-party libraries to Python. The library's use of advanced
      metaprogramming techniques simplifies its syntax for users, so that wrapping
      code takes on the look of a kind of declarative interface definition language
      (IDL).
    </para>
    <bridgehead renderas="sect2" id="tutorial.quickstart.h0">
      <phrase id="tutorial.quickstart.hello_world"/><link linkend="tutorial.quickstart.hello_world">Hello
      World</link>
    </bridgehead>
    <para>
      Following C/C++ tradition, let's start with the "hello, world". A
      C++ Function:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
   <phrase role="keyword">return</phrase> <phrase role="string">"hello, world"</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      can be exposed to Python by writing a Boost.Python wrapper:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello_ext</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"greet"</phrase><phrase role="special">,</phrase> <phrase role="identifier">greet</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      That's it. We're done. We can now build this as a shared library. The resulting
      DLL is now visible to Python. Here's a sample Python session:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">hello_ext</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">hello_ext</phrase><phrase role="special">.</phrase><phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="identifier">hello</phrase><phrase role="special">,</phrase> <phrase role="identifier">world</phrase>
</programlisting>
    <blockquote>
      <para>
        <emphasis><emphasis role="bold">Next stop... Building your Hello World module
        from start to finish...</emphasis></emphasis>
      </para>
    </blockquote>
  </section>
  <section id="tutorial.hello">
    <title><link linkend="tutorial.hello">Building Hello World</link></title>
    <bridgehead renderas="sect2" id="tutorial.hello.h0">
      <phrase id="tutorial.hello.from_start_to_finish"/><link linkend="tutorial.hello.from_start_to_finish">From
      Start To Finish</link>
    </bridgehead>
    <para>
      Now the first thing you'd want to do is to build the Hello World module and
      try it for yourself in Python. In this section, we will outline the steps necessary
      to achieve that. We will use the build tool that comes bundled with every boost
      distribution: <emphasis role="bold">bjam</emphasis>.
    </para>
    <note>
      <para>
        <emphasis role="bold">Building without bjam</emphasis>
      </para>
      <para>
        Besides bjam, there are of course other ways to get your module built. What's
        written here should not be taken as "the one and only way". There
        are of course other build tools apart from <literal moreinfo="none">bjam</literal>.
      </para>
      <para>
        Take note however that the preferred build tool for Boost.Python is bjam.
        There are so many ways to set up the build incorrectly. Experience shows
        that 90% of the "I can't build Boost.Python" problems come from
        people who had to use a different tool.
      </para>
    </note>
    <para>
      We will skip over the details. Our objective will be to simply create the hello
      world module and run it in Python. For a complete reference to building Boost.Python,
      check out: <ulink url="../../../building.html">building.html</ulink>. After
      this brief <emphasis>bjam</emphasis> tutorial, we should have built the DLLs
      and run a python program using the extension.
    </para>
    <para>
      The tutorial example can be found in the directory: <literal moreinfo="none">libs/python/example/tutorial</literal>.
      There, you can find:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          hello.cpp
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          hello.py
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Jamroot
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The <literal moreinfo="none">hello.cpp</literal> file is our C++ hello world example. The
      <literal moreinfo="none">Jamroot</literal> is a minimalist <emphasis>bjam</emphasis> script
      that builds the DLLs for us. Finally, <literal moreinfo="none">hello.py</literal> is our Python
      program that uses the extension in <literal moreinfo="none">hello.cpp</literal>.
    </para>
    <para>
      Before anything else, you should have the bjam executable in your boost directory
      or somewhere in your path such that <literal moreinfo="none">bjam</literal> can be executed
      in the command line. Pre-built Boost.Jam executables are available for most
      platforms. The complete list of Bjam executables can be found <ulink url="http://sourceforge.net/project/showfiles.php?group_id=7586">here</ulink>.
    </para>
    <bridgehead renderas="sect2" id="tutorial.hello.h1">
      <phrase id="tutorial.hello.let_s_jam"/><link linkend="tutorial.hello.let_s_jam">Let's
      Jam!</link>
    </bridgehead>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="../images/jam.png"/></imageobject></inlinemediaobject>
    </para>
    <para>
      <ulink url="../../../../example/tutorial/Jamroot">Here</ulink> is our minimalist
      Jamroot file. Simply copy the file and tweak <literal moreinfo="none">use-project boost</literal>
      to where your boost root directory is and you're OK.
    </para>
    <para>
      The comments contained in the Jamrules file above should be sufficient to get
      you going.
    </para>
    <bridgehead renderas="sect2" id="tutorial.hello.h2">
      <phrase id="tutorial.hello.running_bjam"/><link linkend="tutorial.hello.running_bjam">Running
      bjam</link>
    </bridgehead>
    <para>
      <emphasis>bjam</emphasis> is run using your operating system's command line
      interpreter.
    </para>
    <blockquote>
      <para>
        Start it up.
      </para>
    </blockquote>
    <para>
      A file called user-config.jam in your home directory is used to configure your
      tools. In Windows, your home directory can be found by typing:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">ECHO %HOMEDRIVE%%HOMEPATH%
</programlisting>
    <para>
      into a command prompt window. Your file should at least have the rules for
      your compiler and your python installation. A specific example of this on Windows
      would be:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">#  MSVC configuration
using msvc : 8.0 ;

#  Python configuration
using python : 2.4 : C:<emphasis>dev/tools/Python</emphasis> ;
</programlisting>
    <para>
      The first rule tells Bjam to use the MSVC 8.0 compiler and associated tools.
      The second rule provides information on Python, its version and where it is
      located. The above assumes that the Python installation is in <literal moreinfo="none">C:<emphasis>dev/tools\/Python</emphasis></literal>.
      If you have one fairly "standard" python installation for your platform,
      you might not need to do this.
    </para>
    <para>
      Now we are ready... Be sure to <literal moreinfo="none">cd</literal> to <literal moreinfo="none">libs/python/example/tutorial</literal>
      where the tutorial <literal moreinfo="none">"hello.cpp"</literal> and the <literal moreinfo="none">"Jamroot"</literal>
      is situated.
    </para>
    <para>
      Finally:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">bjam</phrase>
</programlisting>
    <para>
      It should be building now:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">cd C:\dev\boost\libs\python\example\tutorial
bjam
...patience...
...found 1101 targets...
...updating 35 targets...
</programlisting>
    <para>
      And so on... Finally:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">   Creating library <emphasis>path-to-boost_python.dll</emphasis>
   Creating library /path-to-hello_ext.exp/
**passed** ... hello.test
...updated 35 targets...
</programlisting>
    <para>
      Or something similar. If all is well, you should now have built the DLLs and
      run the Python program.
    </para>
    <blockquote>
      <para>
        <emphasis role="bold">There you go... Have fun!</emphasis>
      </para>
    </blockquote>
  </section>
  <section id="tutorial.exposing">
    <title><link linkend="tutorial.exposing">Exposing Classes</link></title>
    <para>
      Now let's expose a C++ class to Python.
    </para>
    <para>
      Consider a C++ class/struct that we want to expose to Python:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">World</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
    <para>
      We can expose this to Python by writing a corresponding Boost.Python C++ Wrapper:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"World"</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"greet"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"set"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
    <para>
      Here, we wrote a C++ class wrapper that exposes the member functions <literal moreinfo="none">greet</literal>
      and <literal moreinfo="none">set</literal>. Now, after building our module as a shared library,
      we may use our class <literal moreinfo="none">World</literal> in Python. Here's a sample Python
      session:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">hello</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">World</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase><phrase role="special">.</phrase><phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="string">'howdy'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase><phrase role="special">.</phrase><phrase role="identifier">greet</phrase><phrase role="special">()</phrase>
<phrase role="string">'howdy'</phrase>
</programlisting>
    <section id="tutorial.exposing.constructors">
      <title><link linkend="tutorial.exposing.constructors">Constructors</link></title>
      <para>
        Our previous example didn't have any explicit constructors. Since <literal moreinfo="none">World</literal>
        is declared as a plain struct, it has an implicit default constructor. Boost.Python
        exposes the default constructor by default, which is why we were able to
        write
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">planet</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">World</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        We may wish to wrap a class with a non-default constructor. Let us build
        on our previous example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">World</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">World</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">):</phrase> <phrase role="identifier">msg</phrase><phrase role="special">(</phrase><phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{}</phrase> <phrase role="comment">// added constructor</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">greet</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">msg</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        This time <literal moreinfo="none">World</literal> has no default constructor; our previous
        wrapping code would fail to compile when the library tried to expose it.
        We have to tell <literal moreinfo="none">class_&lt;World&gt;</literal> about the constructor
        we want to expose instead.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">hello</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"World"</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"greet"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"set"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        <literal moreinfo="none">init&lt;std::string&gt;()</literal> exposes the constructor taking
        in a <literal moreinfo="none">std::string</literal> (in Python, constructors are spelled
        "<literal moreinfo="none">"__init__"</literal>").
      </para>
      <para>
        We can expose additional constructors by passing more <literal moreinfo="none">init&lt;...&gt;</literal>s
        to the <literal moreinfo="none">def()</literal> member function. Say for example we have
        another World constructor taking in two doubles:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">World</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"World"</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"greet"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">greet</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"set"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">World</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">)</phrase>
<phrase role="special">;</phrase>
</programlisting>
      <para>
        On the other hand, if we do not wish to expose any constructors at all, we
        may use <literal moreinfo="none">no_init</literal> instead:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Abstract</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Abstract"</phrase><phrase role="special">,</phrase> <phrase role="identifier">no_init</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        This actually adds an <literal moreinfo="none">__init__</literal> method which always raises
        a Python RuntimeError exception.
      </para>
    </section>
    <section id="tutorial.exposing.class_data_members">
      <title><link linkend="tutorial.exposing.class_data_members">Class Data Members</link></title>
      <para>
        Data members may also be exposed to Python so that they can be accessed as
        attributes of the corresponding Python class. Each data member that we wish
        to be exposed may be regarded as <emphasis role="bold">read-only</emphasis>
        or <emphasis role="bold">read-write</emphasis>. Consider this class <literal moreinfo="none">Var</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Var</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">Var</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase> <phrase role="special">:</phrase> <phrase role="identifier">name</phrase><phrase role="special">(</phrase><phrase role="identifier">name</phrase><phrase role="special">),</phrase> <phrase role="identifier">value</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">name</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">value</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Our C++ <literal moreinfo="none">Var</literal> class and its data members can be exposed
        to Python:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Var</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Var"</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">"name"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Var</phrase><phrase role="special">::</phrase><phrase role="identifier">name</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def_readwrite</phrase><phrase role="special">(</phrase><phrase role="string">"value"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Var</phrase><phrase role="special">::</phrase><phrase role="identifier">value</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Then, in Python, assuming we have placed our Var class inside the namespace
        hello as we did before:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">hello</phrase><phrase role="special">.</phrase><phrase role="identifier">Var</phrase><phrase role="special">(</phrase><phrase role="string">'pi'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="string">'is around'</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase>
<phrase role="identifier">pi</phrase> <phrase role="keyword">is</phrase> <phrase role="identifier">around</phrase> <phrase role="number">3.14</phrase>
</programlisting>
      <para>
        Note that <literal moreinfo="none">name</literal> is exposed as <emphasis role="bold">read-only</emphasis>
        while <literal moreinfo="none">value</literal> is exposed as <emphasis role="bold">read-write</emphasis>.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">name</phrase> <phrase role="special">=</phrase> <phrase role="string">'e'</phrase> <phrase role="comment"># can't change name</phrase>
<phrase role="identifier">Traceback</phrase> <phrase role="special">(</phrase><phrase role="identifier">most</phrase> <phrase role="identifier">recent</phrase> <phrase role="identifier">call</phrase> <phrase role="identifier">last</phrase><phrase role="special">):</phrase>
  <phrase role="identifier">File</phrase> <phrase role="string">"&lt;stdin&gt;"</phrase><phrase role="special">,</phrase> <phrase role="identifier">line</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="keyword">in</phrase> <phrase role="error">?</phrase>
<phrase role="identifier">AttributeError</phrase><phrase role="special">:</phrase> <phrase role="identifier">can</phrase><phrase role="error">'</phrase><phrase role="identifier">t</phrase> <phrase role="identifier">set</phrase> <phrase role="identifier">attribute</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_properties">
      <title><link linkend="tutorial.exposing.class_properties">Class Properties</link></title>
      <para>
        In C++, classes with public data members are usually frowned upon. Well designed
        classes that take advantage of encapsulation hide the class' data members.
        The only way to access the class' data is through access (getter/setter)
        functions. Access functions expose class properties. Here's an example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Num</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">Num</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">get</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">value</phrase><phrase role="special">);</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        However, in Python attribute access is fine; it doesn't neccessarily break
        encapsulation to let users handle attributes directly, because the attributes
        can just be a different syntax for a method call. Wrapping our <literal moreinfo="none">Num</literal>
        class using Boost.Python:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Num</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Num"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">"rovalue"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">"value"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">set</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        And at last, in Python:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Num</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">rovalue</phrase>
<phrase role="special">(</phrase><phrase role="number">3.14</phrase><phrase role="special">,</phrase> <phrase role="number">3.14</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">rovalue</phrase> <phrase role="special">=</phrase> <phrase role="number">2.17</phrase> <phrase role="comment"># error!</phrase>
</programlisting>
      <para>
        Take note that the class property <literal moreinfo="none">rovalue</literal> is exposed as
        <emphasis role="bold">read-only</emphasis> since the <literal moreinfo="none">rovalue</literal>
        setter member function is not passed in:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">add_property</phrase><phrase role="special">(</phrase><phrase role="string">"rovalue"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Num</phrase><phrase role="special">::</phrase><phrase role="identifier">get</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.inheritance">
      <title><link linkend="tutorial.exposing.inheritance">Inheritance</link></title>
      <para>
        In the previous examples, we dealt with classes that are not polymorphic.
        This is not often the case. Much of the time, we will be wrapping polymorphic
        classes and class hierarchies related by inheritance. We will often have
        to write Boost.Python wrappers for classes that are derived from abstract
        base classes.
      </para>
      <para>
        Consider this trivial inheritance structure:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase> <phrase role="special">{</phrase> <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">();</phrase> <phrase role="special">};</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">Derived</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase> <phrase role="special">{};</phrase>
</programlisting>
      <para>
        And a set of C++ functions operating on <literal moreinfo="none">Base</literal> and <literal moreinfo="none">Derived</literal>
        object instances:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">b</phrase><phrase role="special">(</phrase><phrase role="identifier">Base</phrase><phrase role="special">*);</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">d</phrase><phrase role="special">(</phrase><phrase role="identifier">Derived</phrase><phrase role="special">*);</phrase>
<phrase role="identifier">Base</phrase><phrase role="special">*</phrase> <phrase role="identifier">factory</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="keyword">new</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
</programlisting>
      <para>
        We've seen how we can wrap the base class <literal moreinfo="none">Base</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Base"</phrase><phrase role="special">)</phrase>
    <phrase role="comment">/*...*/</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Now we can inform Boost.Python of the inheritance relationship between <literal moreinfo="none">Derived</literal>
        and its base class <literal moreinfo="none">Base</literal>. Thus:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Derived</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;(</phrase><phrase role="string">"Derived"</phrase><phrase role="special">)</phrase>
    <phrase role="comment">/*...*/</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Doing so, we get some things for free:
      </para>
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <simpara>
            Derived automatically inherits all of Base's Python methods (wrapped
            C++ member functions)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">If</emphasis> Base is polymorphic, <literal moreinfo="none">Derived</literal>
            objects which have been passed to Python via a pointer or reference to
            <literal moreinfo="none">Base</literal> can be passed where a pointer or reference to
            <literal moreinfo="none">Derived</literal> is expected.
          </simpara>
        </listitem>
      </orderedlist>
      <para>
        Now, we will expose the C++ free functions <literal moreinfo="none">b</literal> and <literal moreinfo="none">d</literal>
        and <literal moreinfo="none">factory</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"b"</phrase><phrase role="special">,</phrase> <phrase role="identifier">b</phrase><phrase role="special">);</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"d"</phrase><phrase role="special">,</phrase> <phrase role="identifier">d</phrase><phrase role="special">);</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"factory"</phrase><phrase role="special">,</phrase> <phrase role="identifier">factory</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Note that free function <literal moreinfo="none">factory</literal> is being used to generate
        new instances of class <literal moreinfo="none">Derived</literal>. In such cases, we use
        <literal moreinfo="none">return_value_policy&lt;manage_new_object&gt;</literal> to instruct
        Python to adopt the pointer to <literal moreinfo="none">Base</literal> and hold the instance
        in a new Python <literal moreinfo="none">Base</literal> object until the the Python object
        is destroyed. We will see more of Boost.Python <link linkend="tutorial.functions.call_policies">call
        policies</link> later.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// Tell Python to take ownership of factory's result</phrase>
<phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"factory"</phrase><phrase role="special">,</phrase> <phrase role="identifier">factory</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">return_value_policy</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">manage_new_object</phrase><phrase role="special">&gt;());</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_virtual_functions">
      <title><link linkend="tutorial.exposing.class_virtual_functions">Class Virtual
      Functions</link></title>
      <para>
        In this section, we will learn how to make functions behave polymorphically
        through virtual functions. Continuing our example, let us add a virtual function
        to our <literal moreinfo="none">Base</literal> class:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        One of the goals of Boost.Python is to be minimally intrusive on an existing
        C++ design. In principle, it should be possible to expose the interface for
        a 3rd party library without changing it. It is not ideal to add anything
        to our class <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Base</phrase></computeroutput>. Yet, when
        you have a virtual function that's going to be overridden in Python and called
        polymorphically <emphasis role="bold">from C++</emphasis>, we'll need to
        add some scaffoldings to make things work properly. What we'll do is write
        a class wrapper that derives from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Base</phrase></computeroutput>
        that will unintrusively hook into the virtual functions so that a Python
        override may be called:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">BaseWrap</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase> <phrase role="identifier">wrapper</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">)();</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice too that in addition to inheriting from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Base</phrase></computeroutput>,
        we also multiply- inherited <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">wrapper</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase></computeroutput> (See <ulink url="../reference/high_level_components/boost_python_wrapper_hpp.html#high_level_components.boost_python_wrapper_hpp.class_template_wrapper">Wrapper</ulink>).
        The <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">wrapper</phrase></computeroutput> template makes
        the job of wrapping classes that are meant to overridden in Python, easier.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"/></imageobject></inlinemediaobject>
        <emphasis role="bold">MSVC6/7 Workaround</emphasis>
      </para>
      <para>
        If you are using Microsoft Visual C++ 6 or 7, you have to write <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase></computeroutput> as:
      </para>
      <para>
        <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">return</phrase> <phrase role="identifier">call</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">).</phrase><phrase role="identifier">ptr</phrase><phrase role="special">());</phrase></computeroutput>.
      </para>
      </sidebar>
      <para>
        BaseWrap's overridden virtual member function <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase></computeroutput>
        in effect calls the corresponding method of the Python object through <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">get_override</phrase></computeroutput>.
      </para>
      <para>
        Finally, exposing <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Base</phrase></computeroutput>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">,</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">noncopyable</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Base"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">pure_virtual</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">))</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">pure_virtual</phrase></computeroutput> signals Boost.Python
        that the function <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase></computeroutput> is a
        pure virtual function.
      </para>
      <note>
        <para>
          <emphasis role="bold">member function and methods</emphasis>
        </para>
        <para>
          Python, like many object oriented languages uses the term <emphasis role="bold">methods</emphasis>.
          Methods correspond roughly to C++'s <emphasis role="bold">member functions</emphasis>
        </para>
      </note>
    </section>
    <section id="tutorial.exposing.virtual_functions_with_default_i">
      <title><link linkend="tutorial.exposing.virtual_functions_with_default_i">Virtual
      Functions with Default Implementations</link></title>
      <para>
        We've seen in the previous section how classes with pure virtual functions
        are wrapped using Boost.Python's <ulink url="../reference/high_level_components/boost_python_wrapper_hpp.html#high_level_components.boost_python_wrapper_hpp.class_template_wrapper">class
        wrapper</ulink> facilities. If we wish to wrap <emphasis role="bold">non</emphasis>-pure-virtual
        functions instead, the mechanism is a bit different.
      </para>
      <para>
        Recall that in the <link linkend="tutorial.exposing.class_virtual_functions">previous
        section</link>, we wrapped a class with a pure virtual function that we then
        implemented in C++, or Python classes derived from it. Our base class:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        had a pure virtual function <literal moreinfo="none">f</literal>. If, however, its member
        function <literal moreinfo="none">f</literal> was not declared as pure virtual:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Base</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="keyword">virtual</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        We wrap it this way:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">BaseWrap</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase><phrase role="special">,</phrase> <phrase role="identifier">wrapper</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">override</phrase> <phrase role="identifier">f</phrase> <phrase role="special">=</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">get_override</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">))</phrase>
            <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">();</phrase> <phrase role="comment">// *note*</phrase>
        <phrase role="keyword">return</phrase> <phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">int</phrase> <phrase role="identifier">default_f</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice how we implemented <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">BaseWrap</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase></computeroutput>. Now,
        we have to check if there is an override for <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase></computeroutput>.
        If none, then we call <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase></computeroutput>.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"/></imageobject></inlinemediaobject>
        <emphasis role="bold">MSVC6/7 Workaround</emphasis>
      </para>
      <para>
        If you are using Microsoft Visual C++ 6 or 7, you have to rewrite the line
        with the <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">*</phrase><phrase role="identifier">note</phrase><phrase role="special">*</phrase></computeroutput> as:
      </para>
      <para>
        <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">return</phrase> <phrase role="identifier">call</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*&gt;(</phrase><phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">ptr</phrase><phrase role="special">());</phrase></computeroutput>.
      </para>
      </sidebar>
      <para>
        Finally, exposing:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">,</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">noncopyable</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Base"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">::</phrase><phrase role="identifier">default_f</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Take note that we expose both <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&amp;</phrase><phrase role="identifier">Base</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase></computeroutput> and <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&amp;</phrase><phrase role="identifier">BaseWrap</phrase><phrase role="special">::</phrase><phrase role="identifier">default_f</phrase></computeroutput>. Boost.Python needs to keep track
        of 1) the dispatch function <literal moreinfo="none">f</literal> and 2) the forwarding function
        to its default implementation <literal moreinfo="none">default_f</literal>. There's a special
        <literal moreinfo="none">def</literal> function for this purpose.
      </para>
      <para>
        In Python, the results would be as expected:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">base</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Base</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">(</phrase><phrase role="identifier">Base</phrase><phrase role="special">):</phrase>
<phrase role="special">...</phrase>     <phrase role="keyword">def</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
<phrase role="special">...</phrase>         <phrase role="keyword">return</phrase> <phrase role="number">42</phrase>
<phrase role="special">...</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">derived</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        Calling <literal moreinfo="none">base.f()</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">base</phrase><phrase role="special">.</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase>
<phrase role="number">0</phrase>
</programlisting>
      <para>
        Calling <literal moreinfo="none">derived.f()</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">derived</phrase><phrase role="special">.</phrase><phrase role="identifier">f</phrase><phrase role="special">()</phrase>
<phrase role="number">42</phrase>
</programlisting>
    </section>
    <section id="tutorial.exposing.class_operators_special_function">
      <title><link linkend="tutorial.exposing.class_operators_special_function">Class
      Operators/Special Functions</link></title>
      <bridgehead renderas="sect2" id="tutorial.exposing.class_operators_special_function.h0">
        <phrase id="tutorial.exposing.class_operators_special_function.python_operators"/><link linkend="tutorial.exposing.class_operators_special_function.python_operators">Python
        Operators</link>
      </bridgehead>
      <para>
        C is well known for the abundance of operators. C++ extends this to the extremes
        by allowing operator overloading. Boost.Python takes advantage of this and
        makes it easy to wrap C++ operator-powered classes.
      </para>
      <para>
        Consider a file position class <literal moreinfo="none">FilePos</literal> and a set of operators
        that take on FilePos instances:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">class</phrase> <phrase role="identifier">FilePos</phrase> <phrase role="special">{</phrase> <phrase role="comment">/*...*/</phrase> <phrase role="special">};</phrase>

<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">+(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">+(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase>         <phrase role="keyword">operator</phrase><phrase role="special">-(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase>     <phrase role="keyword">operator</phrase><phrase role="special">-(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase><phrase role="special">&amp;</phrase>    <phrase role="keyword">operator</phrase><phrase role="special">+=(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="identifier">FilePos</phrase><phrase role="special">&amp;</phrase>    <phrase role="keyword">operator</phrase><phrase role="special">-=(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&amp;,</phrase> <phrase role="keyword">int</phrase><phrase role="special">);</phrase>
<phrase role="keyword">bool</phrase>        <phrase role="keyword">operator</phrase><phrase role="special">&lt;(</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">,</phrase> <phrase role="identifier">FilePos</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        The class and the various operators can be mapped to Python rather easily
        and intuitively:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">FilePos</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"FilePos"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">+</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>          <phrase role="comment">// __add__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase><phrase role="special">()</phrase> <phrase role="special">+</phrase> <phrase role="identifier">self</phrase><phrase role="special">)</phrase>          <phrase role="comment">// __radd__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-</phrase> <phrase role="identifier">self</phrase><phrase role="special">)</phrase>           <phrase role="comment">// __sub__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>          <phrase role="comment">// __sub__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">+=</phrase> <phrase role="keyword">int</phrase><phrase role="special">())</phrase>         <phrase role="comment">// __iadd__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">-=</phrase> <phrase role="identifier">other</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;())</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">self</phrase><phrase role="special">);</phrase>          <phrase role="comment">// __lt__</phrase>
</programlisting>
      <para>
        The code snippet above is very clear and needs almost no explanation at all.
        It is virtually the same as the operators' signatures. Just take note that
        <literal moreinfo="none">self</literal> refers to FilePos object. Also, not every class
        <literal moreinfo="none">T</literal> that you might need to interact with in an operator
        expression is (cheaply) default-constructible. You can use <literal moreinfo="none">other&lt;T&gt;()</literal>
        in place of an actual <literal moreinfo="none">T</literal> instance when writing "self
        expressions".
      </para>
      <bridgehead renderas="sect2" id="tutorial.exposing.class_operators_special_function.h1">
        <phrase id="tutorial.exposing.class_operators_special_function.special_methods"/><link linkend="tutorial.exposing.class_operators_special_function.special_methods">Special
        Methods</link>
      </bridgehead>
      <para>
        Python has a few more <emphasis>Special Methods</emphasis>. Boost.Python
        supports all of the standard special method names supported by real Python
        class instances. A similar set of intuitive interfaces can also be used to
        wrap C++ functions that correspond to these Python <emphasis>special functions</emphasis>.
        Example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">class</phrase> <phrase role="identifier">Rational</phrase>
<phrase role="special">{</phrase> <phrase role="keyword">public</phrase><phrase role="special">:</phrase> <phrase role="keyword">operator</phrase> <phrase role="keyword">double</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase> <phrase role="special">};</phrase>

<phrase role="identifier">Rational</phrase> <phrase role="identifier">pow</phrase><phrase role="special">(</phrase><phrase role="identifier">Rational</phrase><phrase role="special">,</phrase> <phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>
<phrase role="identifier">Rational</phrase> <phrase role="identifier">abs</phrase><phrase role="special">(</phrase><phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>
<phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;(</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;,</phrase><phrase role="identifier">Rational</phrase><phrase role="special">);</phrase>

<phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Rational</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Rational"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">float_</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                  <phrase role="comment">// __float__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">pow</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">other</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Rational</phrase><phrase role="special">&gt;))</phrase>    <phrase role="comment">// __pow__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">abs</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                     <phrase role="comment">// __abs__</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase>                     <phrase role="comment">// __str__</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        Need we say more?
      </para>
      <note>
        <para>
          What is the business of <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;</phrase></computeroutput>? Well, the method <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">str</phrase></computeroutput> requires the <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;</phrase></computeroutput> to do its work (i.e. <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">operator</phrase><phrase role="special">&lt;&lt;</phrase></computeroutput>
          is used by the method defined by <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">))</phrase></computeroutput>.
        </para>
      </note>
    </section>
  </section>
  <section id="tutorial.functions">
    <title><link linkend="tutorial.functions">Functions</link></title>
    <para>
      In this chapter, we'll look at Boost.Python powered functions in closer detail.
      We will see some facilities to make exposing C++ functions to Python safe from
      potential pifalls such as dangling pointers and references. We will also see
      facilities that will make it even easier for us to expose C++ functions that
      take advantage of C++ features such as overloading and default arguments.
    </para>
    <blockquote>
      <para>
        <emphasis>Read on...</emphasis>
      </para>
    </blockquote>
    <para>
      But before you do, you might want to fire up Python 2.2 or later and type
      <literal moreinfo="none">&gt;&gt;&gt; import this</literal>.
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than <emphasis role="bold">right</emphasis> now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</programlisting>
    <section id="tutorial.functions.call_policies">
      <title><link linkend="tutorial.functions.call_policies">Call Policies</link></title>
      <para>
        In C++, we often deal with arguments and return types such as pointers and
        references. Such primitive types are rather, ummmm, low level and they really
        don't tell us much. At the very least, we don't know the owner of the pointer
        or the referenced object. No wonder languages such as Java and Python never
        deal with such low level entities. In C++, it's usually considered a good
        practice to use smart pointers which exactly describe ownership semantics.
        Still, even good C++ interfaces use raw references and pointers sometimes,
        so Boost.Python must deal with them. To do this, it may need your help. Consider
        the following C++ function:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        How should the library wrap this function? A naive approach builds a Python
        X object around result reference. This strategy might or might not work out.
        Here's an example where it didn't
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase> <phrase role="special">#</phrase> <phrase role="identifier">x</phrase> <phrase role="identifier">refers</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">some</phrase> <phrase role="identifier">C</phrase><phrase role="special">++</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">del</phrase> <phrase role="identifier">y</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">some_method</phrase><phrase role="special">()</phrase> <phrase role="special">#</phrase> <phrase role="identifier">CRASH</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        What's the problem?
      </para>
      <para>
        Well, what if f() was implemented as shown below:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z</phrase> <phrase role="special">=</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The problem is that the lifetime of result X&amp; is tied to the lifetime
        of y, because the f() returns a reference to a member of the y object. This
        idiom is is not uncommon and perfectly acceptable in the context of C++.
        However, Python users should not be able to crash the system just by using
        our C++ interface. In this case deleting y will invalidate the reference
        to X. We have a dangling reference.
      </para>
      <para>
        Here's what's happening:
      </para>
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <simpara>
            <literal moreinfo="none">f</literal> is called passing in a reference to <literal moreinfo="none">y</literal>
            and a pointer to <literal moreinfo="none">z</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A reference to <literal moreinfo="none">y.x</literal> is returned
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal moreinfo="none">y</literal> is deleted. <literal moreinfo="none">x</literal> is a dangling reference
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal moreinfo="none">x.some_method()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">BOOM!</emphasis>
          </simpara>
        </listitem>
      </orderedlist>
      <para>
        We could copy result into a new object:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">).</phrase><phrase role="identifier">set</phrase><phrase role="special">(</phrase><phrase role="number">42</phrase><phrase role="special">)</phrase> <phrase role="comment"># Result disappears</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">get</phrase><phrase role="special">()</phrase>       <phrase role="comment"># No crash, but still bad</phrase>
<phrase role="number">3.14</phrase>
</programlisting>
      <para>
        This is not really our intent of our C++ interface. We've broken our promise
        that the Python interface should reflect the C++ interface as closely as
        possible.
      </para>
      <para>
        Our problems do not end there. Suppose Y is implemented as follows:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">Y</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">X</phrase> <phrase role="identifier">x</phrase><phrase role="special">;</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">z_value</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">z</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">value</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Notice that the data member <literal moreinfo="none">z</literal> is held by class Y using
        a raw pointer. Now we have a potential dangling pointer problem inside Y:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase> <phrase role="special">#</phrase> <phrase role="identifier">y</phrase> <phrase role="identifier">refers</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">z</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">del</phrase> <phrase role="identifier">z</phrase>       <phrase role="special">#</phrase> <phrase role="identifier">Kill</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">z</phrase> <phrase role="identifier">object</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z_value</phrase><phrase role="special">()</phrase> <phrase role="special">#</phrase> <phrase role="identifier">CRASH</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        For reference, here's the implementation of <literal moreinfo="none">f</literal> again:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">X</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">y</phrase><phrase role="special">,</phrase> <phrase role="identifier">Z</phrase><phrase role="special">*</phrase> <phrase role="identifier">z</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">z</phrase> <phrase role="special">=</phrase> <phrase role="identifier">z</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">y</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Here's what's happening:
      </para>
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <simpara>
            <literal moreinfo="none">f</literal> is called passing in a reference to <literal moreinfo="none">y</literal>
            and a pointer to <literal moreinfo="none">z</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A pointer to <literal moreinfo="none">z</literal> is held by <literal moreinfo="none">y</literal>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            A reference to <literal moreinfo="none">y.x</literal> is returned
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal moreinfo="none">z</literal> is deleted. <literal moreinfo="none">y.z</literal> is a dangling
            pointer
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal moreinfo="none">y.z_value()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <literal moreinfo="none">z-&gt;value()</literal> is called
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">BOOM!</emphasis>
          </simpara>
        </listitem>
      </orderedlist>
      <bridgehead renderas="sect2" id="tutorial.functions.call_policies.h0">
        <phrase id="tutorial.functions.call_policies.call_policies"/><link linkend="tutorial.functions.call_policies.call_policies">Call
        Policies</link>
      </bridgehead>
      <para>
        Call Policies may be used in situations such as the example detailed above.
        In our example, <literal moreinfo="none">return_internal_reference</literal> and <literal moreinfo="none">with_custodian_and_ward</literal>
        are our friends:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">,</phrase>
    <phrase role="identifier">return_internal_reference</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase>
        <phrase role="identifier">with_custodian_and_ward</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">2</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;());</phrase>
</programlisting>
      <para>
        What are the <literal moreinfo="none">1</literal> and <literal moreinfo="none">2</literal> parameters, you
        ask?
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">return_internal_reference</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase>
</programlisting>
      <para>
        Informs Boost.Python that the first argument, in our case <literal moreinfo="none">Y&amp;
        y</literal>, is the owner of the returned reference: <literal moreinfo="none">X&amp;</literal>.
        The "<literal moreinfo="none">1</literal>" simply specifies the first argument.
        In short: "return an internal reference <literal moreinfo="none">X&amp;</literal> owned
        by the 1st argument <literal moreinfo="none">Y&amp; y</literal>".
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">with_custodian_and_ward</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">2</phrase><phrase role="special">&gt;</phrase>
</programlisting>
      <para>
        Informs Boost.Python that the lifetime of the argument indicated by ward
        (i.e. the 2nd argument: <literal moreinfo="none">Z* z</literal>) is dependent on the lifetime
        of the argument indicated by custodian (i.e. the 1st argument: <literal moreinfo="none">Y&amp;
        y</literal>).
      </para>
      <para>
        It is also important to note that we have defined two policies above. Two
        or more policies can be composed by chaining. Here's the general syntax:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">policy1</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...,</phrase>
    <phrase role="identifier">policy2</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...,</phrase>
        <phrase role="identifier">policy3</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">args</phrase><phrase role="special">...&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>
</programlisting>
      <para>
        Here is the list of predefined call policies. A complete reference detailing
        these can be found <ulink url="../reference/function_invocation_and_creation/models_of_callpolicies.html">here</ulink>.
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            <emphasis role="bold">with_custodian_and_ward</emphasis>: Ties lifetimes
            of the arguments
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">with_custodian_and_ward_postcall</emphasis>: Ties
            lifetimes of the arguments and results
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">return_internal_reference</emphasis>: Ties lifetime
            of one argument to that of result
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            <emphasis role="bold">return_value_policy&lt;T&gt; with T one of:</emphasis>
            <itemizedlist>
              <listitem>
                <simpara>
                  <emphasis role="bold">reference_existing_object</emphasis>: naive
                  (dangerous) approach
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">copy_const_reference</emphasis>: Boost.Python
                  v1 approach
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">copy_non_const_reference</emphasis>:
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  <emphasis role="bold">manage_new_object</emphasis>: Adopt a pointer
                  and hold the instance
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
      </itemizedlist>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/smiley.png"/></imageobject></inlinemediaobject>
        <emphasis role="bold">Remember the Zen, Luke:</emphasis>
      </para>
      <para>
        "Explicit is better than implicit"
      </para>
      <para>
        "In the face of ambiguity, refuse the temptation to guess"
      </para>
      </sidebar>
    </section>
    <section id="tutorial.functions.overloading">
      <title><link linkend="tutorial.functions.overloading">Overloading</link></title>
      <para>
        The following illustrates a scheme for manually wrapping an overloaded member
        functions. Of course, the same technique can be applied to wrapping overloaded
        non-member functions.
      </para>
      <para>
        We have here our C++ class:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">b</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">bool</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>

    <phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">return</phrase> <phrase role="identifier">a</phrase> <phrase role="special">+</phrase> <phrase role="identifier">b</phrase> <phrase role="special">+</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>
    <phrase role="special">};</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        Class X has 4 overloaded functions. We will start by introducing some member
        function pointer variables:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx1</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">)</phrase>              <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx2</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">)</phrase>      <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx3</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">)=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">int</phrase>     <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx4</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">)</phrase>    <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        With these in hand, we can proceed to define and wrap this for Python:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx1</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx2</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx3</phrase><phrase role="special">)</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx4</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
    <section id="tutorial.functions.default_arguments">
      <title><link linkend="tutorial.functions.default_arguments">Default Arguments</link></title>
      <para>
        Boost.Python wraps (member) function pointers. Unfortunately, C++ function
        pointers carry no default argument info. Take a function <literal moreinfo="none">f</literal>
        with default arguments:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">int</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="special">=</phrase> <phrase role="number">3.14</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*</phrase> <phrase role="special">=</phrase> <phrase role="string">"hello"</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        But the type of a pointer to the function <literal moreinfo="none">f</literal> has no information
        about its default arguments:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">int</phrase><phrase role="special">(*</phrase><phrase role="identifier">g</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase><phrase role="keyword">char</phrase> <phrase role="keyword">const</phrase><phrase role="special">*)</phrase> <phrase role="special">=</phrase> <phrase role="identifier">f</phrase><phrase role="special">;</phrase>    <phrase role="comment">// defaults lost!</phrase>
</programlisting>
      <para>
        When we pass this function pointer to the <literal moreinfo="none">def</literal> function,
        there is no way to retrieve the default arguments:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">);</phrase>                            <phrase role="comment">// defaults lost!</phrase>
</programlisting>
      <para>
        Because of this, when wrapping C++ code, we had to resort to manual wrapping
        as outlined in the <link linkend="tutorial.functions.overloading">previous
        section</link>, or writing thin wrappers:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">// write "thin wrappers"</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">f1</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">);</phrase> <phrase role="special">}</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">f2</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase><phrase role="identifier">y</phrase><phrase role="special">);</phrase> <phrase role="special">}</phrase>

<phrase role="comment">/*...*/</phrase>

    <phrase role="comment">// in module init</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">);</phrase>  <phrase role="comment">// all arguments</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">f2</phrase><phrase role="special">);</phrase> <phrase role="comment">// two arguments</phrase>
    <phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">f1</phrase><phrase role="special">);</phrase> <phrase role="comment">// one argument</phrase>
</programlisting>
      <para>
        When you want to wrap functions (or member functions) that either:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            have default arguments, or
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            are overloaded with a common sequence of initial arguments
          </simpara>
        </listitem>
      </itemizedlist>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h0">
        <phrase id="tutorial.functions.default_arguments.boost_python_function_overloads"/><link linkend="tutorial.functions.default_arguments.boost_python_function_overloads">BOOST_PYTHON_FUNCTION_OVERLOADS</link>
      </bridgehead>
      <para>
        Boost.Python now has a way to make it easier. For instance, given a function:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">int</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The macro invocation:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">BOOST_PYTHON_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">foo_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        will automatically create the thin wrappers for us. This macro will create
        a class <literal moreinfo="none">foo_overloads</literal> that can be passed on to <literal moreinfo="none">def(...)</literal>.
        The third and fourth macro argument are the minimum arguments and maximum
        arguments, respectively. In our <literal moreinfo="none">foo</literal> function the minimum
        number of arguments is 1 and the maximum number of arguments is 4. The <literal moreinfo="none">def(...)</literal>
        function will automatically add all the foo variants for us:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"foo"</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h1">
        <phrase id="tutorial.functions.default_arguments.boost_python_member_function_ove"/><link linkend="tutorial.functions.default_arguments.boost_python_member_function_ove">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</link>
      </bridgehead>
      <para>
        Objects here, objects there, objects here there everywhere. More frequently
        than anything else, we need to expose member functions of our classes to
        Python. Then again, we have the same inconveniences as before when default
        arguments or overloads with a common sequence of initial arguments come into
        play. Another macro is provided to make this a breeze.
      </para>
      <para>
        Like <literal moreinfo="none">BOOST_PYTHON_FUNCTION_OVERLOADS</literal>, <literal moreinfo="none">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        may be used to automatically create the thin wrappers for wrapping member
        functions. Let's have an example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">george</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase>
    <phrase role="identifier">wack_em</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="char">'x'</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">/*...*/</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        The macro invocation:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">george_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">wack_em</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        will generate a set of thin wrappers for george's <literal moreinfo="none">wack_em</literal>
        member function accepting a minimum of 1 and a maximum of 3 arguments (i.e.
        the third and fourth macro argument). The thin wrappers are all enclosed
        in a class named <literal moreinfo="none">george_overloads</literal> that can then be used
        as an argument to <literal moreinfo="none">def(...)</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"wack_em"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">george</phrase><phrase role="special">::</phrase><phrase role="identifier">wack_em</phrase><phrase role="special">,</phrase> <phrase role="identifier">george_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        See the <ulink url="../reference/function_invocation_and_creation/boost_python_overloads_hpp.html#function_invocation_and_creation.boost_python_overloads_hpp.macros">overloads
        reference</ulink> for details.
      </para>
      <bridgehead renderas="sect2" id="tutorial.functions.default_arguments.h2">
        <phrase id="tutorial.functions.default_arguments.init_and_optional"/><link linkend="tutorial.functions.default_arguments.init_and_optional">init and
        optional</link>
      </bridgehead>
      <para>
        A similar facility is provided for class constructors, again, with default
        arguments or a sequence of overloads. Remember <literal moreinfo="none">init&lt;...&gt;</literal>?
        For example, given a class X with a constructor:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">struct</phrase> <phrase role="identifier">X</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">X</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">b</phrase> <phrase role="special">=</phrase> <phrase role="char">'D'</phrase><phrase role="special">,</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="string">"constructor"</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="number">0.0</phrase><phrase role="special">);</phrase>
    <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        You can easily add this constructor to Boost.Python in one shot:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="identifier">optional</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">,</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;())</phrase>
</programlisting>
      <para>
        Notice the use of <literal moreinfo="none">init&lt;...&gt;</literal> and <literal moreinfo="none">optional&lt;...&gt;</literal>
        to signify the default (optional arguments).
      </para>
    </section>
    <section id="tutorial.functions.auto_overloading">
      <title><link linkend="tutorial.functions.auto_overloading">Auto-Overloading</link></title>
      <para>
        It was mentioned in passing in the previous section that <literal moreinfo="none">BOOST_PYTHON_FUNCTION_OVERLOADS</literal>
        and <literal moreinfo="none">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal> can also be
        used for overloaded functions and member functions with a common sequence
        of initial arguments. Here is an example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="keyword">bool</phrase> <phrase role="identifier">a</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">b</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="identifier">c</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
   <phrase role="comment">/*...*/</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Like in the previous section, we can generate thin wrappers for these overloaded
        functions in one-shot:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">BOOST_PYTHON_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">foo_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo</phrase><phrase role="special">,</phrase> <phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="number">3</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Then...
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"foo"</phrase><phrase role="special">,</phrase> <phrase role="special">(</phrase><phrase role="keyword">void</phrase><phrase role="special">(*)(</phrase><phrase role="keyword">bool</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">))</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="identifier">foo_overloads</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        Notice though that we have a situation now where we have a minimum of zero
        (0) arguments and a maximum of 3 arguments.
      </para>
      <bridgehead renderas="sect2" id="tutorial.functions.auto_overloading.h0">
        <phrase id="tutorial.functions.auto_overloading.manual_wrapping"/><link linkend="tutorial.functions.auto_overloading.manual_wrapping">Manual
        Wrapping</link>
      </bridgehead>
      <para>
        It is important to emphasize however that <emphasis role="bold">the overloaded
        functions must have a common sequence of initial arguments</emphasis>. Otherwise,
        our scheme above will not work. If this is not the case, we have to wrap
        our functions <link linkend="tutorial.functions.overloading">manually</link>.
      </para>
      <para>
        Actually, we can mix and match manual wrapping of overloaded functions and
        automatic wrapping through <literal moreinfo="none">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        and its sister, <literal moreinfo="none">BOOST_PYTHON_FUNCTION_OVERLOADS</literal>. Following
        up on our example presented in the section <link linkend="tutorial.functions.overloading">on
        overloading</link>, since the first 4 overload functins have a common sequence
        of initial arguments, we can use <literal moreinfo="none">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</literal>
        to automatically wrap the first three of the <literal moreinfo="none">def</literal>s and
        manually wrap just the last. Here's how we'll do this:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</phrase><phrase role="special">(</phrase><phrase role="identifier">xf_overloads</phrase><phrase role="special">,</phrase> <phrase role="identifier">f</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="number">4</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Create a member function pointers as above for both X::f overloads:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">bool</phrase>    <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx1</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase><phrase role="special">)</phrase>    <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
<phrase role="keyword">int</phrase>     <phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">::*</phrase><phrase role="identifier">fx2</phrase><phrase role="special">)(</phrase><phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">,</phrase> <phrase role="keyword">int</phrase><phrase role="special">)</phrase>        <phrase role="special">=</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Then...
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx1</phrase><phrase role="special">,</phrase> <phrase role="identifier">xf_overloads</phrase><phrase role="special">());</phrase>
<phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"f"</phrase><phrase role="special">,</phrase> <phrase role="identifier">fx2</phrase><phrase role="special">)</phrase>
</programlisting>
    </section>
  </section>
  <section id="tutorial.object">
    <title><link linkend="tutorial.object">Object Interface</link></title>
    <para>
      Python is dynamically typed, unlike C++ which is statically typed. Python variables
      may hold an integer, a float, list, dict, tuple, str, long etc., among other
      things. In the viewpoint of Boost.Python and C++, these Pythonic variables
      are just instances of class <literal moreinfo="none">object</literal>. We will see in this
      chapter how to deal with Python objects.
    </para>
    <para>
      As mentioned, one of the goals of Boost.Python is to provide a bidirectional
      mapping between C++ and Python while maintaining the Python feel. Boost.Python
      C++ <literal moreinfo="none">object</literal>s are as close as possible to Python. This should
      minimize the learning curve significantly.
    </para>
    <para>
      <inlinemediaobject><imageobject><imagedata fileref="../images/python.png"/></imageobject></inlinemediaobject>
    </para>
    <section id="tutorial.object.basic_interface">
      <title><link linkend="tutorial.object.basic_interface">Basic Interface</link></title>
      <para>
        Class <literal moreinfo="none">object</literal> wraps <literal moreinfo="none">PyObject*</literal>. All the
        intricacies of dealing with <literal moreinfo="none">PyObject</literal>s such as managing
        reference counting are handled by the <literal moreinfo="none">object</literal> class. C++
        object interoperability is seamless. Boost.Python C++ <literal moreinfo="none">object</literal>s
        can in fact be explicitly constructed from any C++ object.
      </para>
      <para>
        To illustrate, this Python code snippet:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">def</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">):</phrase>
     <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">y</phrase> <phrase role="special">==</phrase> <phrase role="string">'foo'</phrase><phrase role="special">):</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">[</phrase><phrase role="number">3</phrase><phrase role="special">:</phrase><phrase role="number">7</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="string">'bar'</phrase>
     <phrase role="keyword">else</phrase><phrase role="special">:</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">items</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">y</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase>
     <phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase>

<phrase role="keyword">def</phrase> <phrase role="identifier">getfunc</phrase><phrase role="special">():</phrase>
   <phrase role="keyword">return</phrase> <phrase role="identifier">f</phrase><phrase role="special">;</phrase>
</programlisting>
      <para>
        Can be rewritten in C++ using Boost.Python facilities this way:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
     <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">y</phrase> <phrase role="special">==</phrase> <phrase role="string">"foo"</phrase><phrase role="special">)</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">slice</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase><phrase role="number">7</phrase><phrase role="special">)</phrase> <phrase role="special">=</phrase> <phrase role="string">"bar"</phrase><phrase role="special">;</phrase>
     <phrase role="keyword">else</phrase>
         <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"items"</phrase><phrase role="special">)</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">y</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">x</phrase><phrase role="special">);</phrase>
     <phrase role="keyword">return</phrase> <phrase role="identifier">x</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">getfunc</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">object</phrase><phrase role="special">(</phrase><phrase role="identifier">f</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Apart from cosmetic differences due to the fact that we are writing the code
        in C++, the look and feel should be immediately apparent to the Python coder.
      </para>
    </section>
    <section id="tutorial.object.derived_object_types">
      <title><link linkend="tutorial.object.derived_object_types">Derived Object
      types</link></title>
      <para>
        Boost.Python comes with a set of derived <literal moreinfo="none">object</literal> types
        corresponding to that of Python's:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            list
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            dict
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            tuple
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            str
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            long_
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            enum
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        These derived <literal moreinfo="none">object</literal> types act like real Python types.
        For instance:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">==&gt;</phrase> <phrase role="string">"1"</phrase>
</programlisting>
      <para>
        Wherever appropriate, a particular derived <literal moreinfo="none">object</literal> has
        corresponding Python type's methods. For instance, <literal moreinfo="none">dict</literal>
        has a <literal moreinfo="none">keys()</literal> method:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">d</phrase><phrase role="special">.</phrase><phrase role="identifier">keys</phrase><phrase role="special">()</phrase>
</programlisting>
      <para>
        <literal moreinfo="none">make_tuple</literal> is provided for declaring <emphasis>tuple literals</emphasis>.
        Example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="number">123</phrase><phrase role="special">,</phrase> <phrase role="char">'D'</phrase><phrase role="special">,</phrase> <phrase role="string">"Hello, World"</phrase><phrase role="special">,</phrase> <phrase role="number">0.0</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        In C++, when Boost.Python <literal moreinfo="none">object</literal>s are used as arguments
        to functions, subtype matching is required. For example, when a function
        <literal moreinfo="none">f</literal>, as declared below, is wrapped, it will only accept
        instances of Python's <literal moreinfo="none">str</literal> type and subtypes.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">f</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">n2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"upper"</phrase><phrase role="special">)();</phrase>   <phrase role="comment">// NAME = name.upper()</phrase>
    <phrase role="identifier">str</phrase> <phrase role="identifier">NAME</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">upper</phrase><phrase role="special">();</phrase>            <phrase role="comment">// better</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="string">"%s is bigger than %s"</phrase> <phrase role="special">%</phrase> <phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="identifier">NAME</phrase><phrase role="special">,</phrase><phrase role="identifier">name</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        In finer detail:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">str</phrase> <phrase role="identifier">NAME</phrase> <phrase role="special">=</phrase> <phrase role="identifier">name</phrase><phrase role="special">.</phrase><phrase role="identifier">upper</phrase><phrase role="special">();</phrase>
</programlisting>
      <para>
        Illustrates that we provide versions of the str type's methods as C++ member
        functions.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">msg</phrase> <phrase role="special">=</phrase> <phrase role="string">"%s is bigger than %s"</phrase> <phrase role="special">%</phrase> <phrase role="identifier">make_tuple</phrase><phrase role="special">(</phrase><phrase role="identifier">NAME</phrase><phrase role="special">,</phrase><phrase role="identifier">name</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        Demonstrates that you can write the C++ equivalent of <literal moreinfo="none">"format"
        % x,y,z</literal> in Python, which is useful since there's no easy way to
        do that in std C++.
      </para>
      <sidebar role="blurb">
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/alert.png"/></imageobject></inlinemediaobject>
        <emphasis role="bold">Beware</emphasis> the common pitfall of forgetting
        that the constructors of most of Python's mutable types make copies, just
        as in Python.
      </para>
      </sidebar>
      <para>
        Python:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="identifier">dict</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">__dict__</phrase><phrase role="special">)</phrase>     <phrase role="comment"># copies x.__dict__</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="string">'whatever'</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase>        <phrase role="comment"># modifies the copy</phrase>
</programlisting>
      <para>
        C++:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">dict</phrase> <phrase role="identifier">d</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"__dict__"</phrase><phrase role="special">));</phrase>  <phrase role="comment">// copies x.__dict__</phrase>
<phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="char">'whatever'</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>           <phrase role="comment">// modifies the copy</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.object.derived_object_types.h0">
        <phrase id="tutorial.object.derived_object_types.class_t_as_objects"/><link linkend="tutorial.object.derived_object_types.class_t_as_objects">class_&lt;T&gt;
        as objects</link>
      </bridgehead>
      <para>
        Due to the dynamic nature of Boost.Python objects, any <literal moreinfo="none">class_&lt;T&gt;</literal>
        may also be one of these types! The following code snippet wraps the class
        (type) object.
      </para>
      <para>
        We can use this to create wrapped instances. Example:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">vec345</phrase> <phrase role="special">=</phrase> <phrase role="special">(</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Vec2"</phrase><phrase role="special">,</phrase> <phrase role="identifier">init</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">,</phrase> <phrase role="keyword">double</phrase><phrase role="special">&gt;())</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">"length"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Point</phrase><phrase role="special">::</phrase><phrase role="identifier">length</phrase><phrase role="special">)</phrase>
        <phrase role="special">.</phrase><phrase role="identifier">def_readonly</phrase><phrase role="special">(</phrase><phrase role="string">"angle"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">Point</phrase><phrase role="special">::</phrase><phrase role="identifier">angle</phrase><phrase role="special">)</phrase>
    <phrase role="special">)(</phrase><phrase role="number">3.0</phrase><phrase role="special">,</phrase> <phrase role="number">4.0</phrase><phrase role="special">);</phrase>

<phrase role="identifier">assert</phrase><phrase role="special">(</phrase><phrase role="identifier">vec345</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"length"</phrase><phrase role="special">)</phrase> <phrase role="special">==</phrase> <phrase role="number">5.0</phrase><phrase role="special">);</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.extracting_c_objects">
      <title><link linkend="tutorial.object.extracting_c_objects">Extracting C++
      objects</link></title>
      <para>
        At some point, we will need to get C++ values out of object instances. This
        can be achieved with the <literal moreinfo="none">extract&lt;T&gt;</literal> function. Consider
        the following:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">double</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">o</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"length"</phrase><phrase role="special">);</phrase> <phrase role="comment">// compile error</phrase>
</programlisting>
      <para>
        In the code above, we got a compiler error because Boost.Python <literal moreinfo="none">object</literal>
        can't be implicitly converted to <literal moreinfo="none">double</literal>s. Instead, what
        we wanted to do above can be achieved by writing:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">double</phrase> <phrase role="identifier">l</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">double</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">o</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"length"</phrase><phrase role="special">));</phrase>
<phrase role="identifier">Vec2</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&amp;&gt;(</phrase><phrase role="identifier">o</phrase><phrase role="special">);</phrase>
<phrase role="identifier">assert</phrase><phrase role="special">(</phrase><phrase role="identifier">l</phrase> <phrase role="special">==</phrase> <phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">length</phrase><phrase role="special">());</phrase>
</programlisting>
      <para>
        The first line attempts to extract the "length" attribute of the
        Boost.Python <literal moreinfo="none">object</literal>. The second line attempts to <emphasis>extract</emphasis>
        the <literal moreinfo="none">Vec2</literal> object from held by the Boost.Python <literal moreinfo="none">object</literal>.
      </para>
      <para>
        Take note that we said "attempt to" above. What if the Boost.Python
        <literal moreinfo="none">object</literal> does not really hold a <literal moreinfo="none">Vec2</literal>
        type? This is certainly a possibility considering the dynamic nature of Python
        <literal moreinfo="none">object</literal>s. To be on the safe side, if the C++ type can't
        be extracted, an appropriate exception is thrown. To avoid an exception,
        we need to test for extractibility:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Vec2</phrase><phrase role="special">&amp;&gt;</phrase> <phrase role="identifier">x</phrase><phrase role="special">(</phrase><phrase role="identifier">o</phrase><phrase role="special">);</phrase>
<phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">check</phrase><phrase role="special">())</phrase> <phrase role="special">{</phrase>
    <phrase role="identifier">Vec2</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="identifier">x</phrase><phrase role="special">();</phrase> <phrase role="special">...</phrase>
</programlisting>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../images/tip.png"/></imageobject></inlinemediaobject>
        The astute reader might have noticed that the <literal moreinfo="none">extract&lt;T&gt;</literal>
        facility in fact solves the mutable copying problem:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">dict</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">dict</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"__dict__"</phrase><phrase role="special">));</phrase>
<phrase role="identifier">d</phrase><phrase role="special">[</phrase><phrase role="string">"whatever"</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>          <phrase role="comment">// modifies x.__dict__ !</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.enums">
      <title><link linkend="tutorial.object.enums">Enums</link></title>
      <para>
        Boost.Python has a nifty facility to capture and wrap C++ enums. While Python
        has no <literal moreinfo="none">enum</literal> type, we'll often want to expose our C++ enums
        to Python as an <literal moreinfo="none">int</literal>. Boost.Python's enum facility makes
        this easy while taking care of the proper conversions from Python's dynamic
        typing to C++'s strong static typing (in C++, ints cannot be implicitly converted
        to enums). To illustrate, given a C++ enum:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">enum</phrase> <phrase role="identifier">choice</phrase> <phrase role="special">{</phrase> <phrase role="identifier">red</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase> <phrase role="special">};</phrase>
</programlisting>
      <para>
        the construct:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">enum_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">choice</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"choice"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">"red"</phrase><phrase role="special">,</phrase> <phrase role="identifier">red</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">"blue"</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
      <para>
        can be used to expose to Python. The new enum type is created in the current
        <literal moreinfo="none">scope()</literal>, which is usually the current module. The snippet
        above creates a Python class derived from Python's <literal moreinfo="none">int</literal>
        type which is associated with the C++ type passed as its first parameter.
      </para>
      <note>
        <para>
          <emphasis role="bold">what is a scope?</emphasis>
        </para>
        <para>
          The scope is a class that has an associated global Python object which
          controls the Python namespace in which new extension classes and wrapped
          functions will be defined as attributes. Details can be found <ulink url="../reference/high_level_components/boost_python_scope_hpp.html#high_level_components.boost_python_scope_hpp.class_scope">here</ulink>.
        </para>
      </note>
      <para>
        You can access those values in Python as
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">my_module</phrase><phrase role="special">.</phrase><phrase role="identifier">choice</phrase><phrase role="special">.</phrase><phrase role="identifier">red</phrase>
<phrase role="identifier">my_module</phrase><phrase role="special">.</phrase><phrase role="identifier">choice</phrase><phrase role="special">.</phrase><phrase role="identifier">red</phrase>
</programlisting>
      <para>
        where my_module is the module where the enum is declared. You can also create
        a new scope around a class:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">scope</phrase> <phrase role="identifier">in_X</phrase> <phrase role="special">=</phrase> <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">X</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"X"</phrase><phrase role="special">)</phrase>
                <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase> <phrase role="special">...</phrase> <phrase role="special">)</phrase>
                <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase> <phrase role="special">...</phrase> <phrase role="special">)</phrase>
            <phrase role="special">;</phrase>

<phrase role="comment">// Expose X::nested as X.nested</phrase>
<phrase role="identifier">enum_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">nested</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"nested"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">"red"</phrase><phrase role="special">,</phrase> <phrase role="identifier">red</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="string">"blue"</phrase><phrase role="special">,</phrase> <phrase role="identifier">blue</phrase><phrase role="special">)</phrase>
    <phrase role="special">;</phrase>
</programlisting>
    </section>
    <section id="tutorial.object.creating_python_object">
      <title><link linkend="tutorial.object.creating_python_object">Creating <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase></computeroutput>
      from <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">PyObject</phrase><phrase role="special">*</phrase></computeroutput></link></title>
      <para>
        When you want a <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase></computeroutput> to manage a pointer to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">PyObject</phrase><phrase role="special">*</phrase></computeroutput>
        pyobj one does:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;&gt;(</phrase><phrase role="identifier">pyobj</phrase><phrase role="special">));</phrase>
</programlisting>
      <para>
        In this case, the <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">o</phrase></computeroutput> object,
        manages the <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">pyobj</phrase></computeroutput>, it wont
        increase the reference count on construction.
      </para>
      <para>
        Otherwise, to use a borrowed reference:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">handle</phrase><phrase role="special">&lt;&gt;(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">python</phrase><phrase role="special">::</phrase><phrase role="identifier">borrowed</phrase><phrase role="special">(</phrase><phrase role="identifier">pyobj</phrase><phrase role="special">)));</phrase>
</programlisting>
      <para>
        In this case, <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">Py_INCREF</phrase></computeroutput> is
        called, so <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">pyobj</phrase></computeroutput> is not destructed
        when object o goes out of scope.
      </para>
    </section>
  </section>
  <section id="tutorial.embedding">
    <title><link linkend="tutorial.embedding">Embedding</link></title>
    <para>
      By now you should know how to use Boost.Python to call your C++ code from Python.
      However, sometimes you may need to do the reverse: call Python code from the
      C++-side. This requires you to <emphasis>embed</emphasis> the Python interpreter
      into your C++ program.
    </para>
    <para>
      Currently, Boost.Python does not directly support everything you'll need when
      embedding. Therefore you'll need to use the <ulink url="http://www.python.org/doc/current/api/api.html">Python/C
      API</ulink> to fill in the gaps. However, Boost.Python already makes embedding
      a lot easier and, in a future version, it may become unnecessary to touch the
      Python/C API at all. So stay tuned... <inlinemediaobject><imageobject><imagedata fileref="../images/smiley.png"/></imageobject></inlinemediaobject>
    </para>
    <bridgehead renderas="sect2" id="tutorial.embedding.h0">
      <phrase id="tutorial.embedding.building_embedded_programs"/><link linkend="tutorial.embedding.building_embedded_programs">Building
      embedded programs</link>
    </bridgehead>
    <para>
      To be able to embed python into your programs, you have to link to both Boost.Python's
      as well as Python's own runtime library.
    </para>
    <para>
      Boost.Python's library comes in two variants. Both are located in Boost's
      <literal moreinfo="none">/libs/python/build/bin-stage</literal> subdirectory. On Windows, the
      variants are called <literal moreinfo="none">boost_python.lib</literal> (for release builds)
      and <literal moreinfo="none">boost_python_debug.lib</literal> (for debugging). If you can't
      find the libraries, you probably haven't built Boost.Python yet. See <ulink url="../../../building.html">Building and Testing</ulink> on how to do this.
    </para>
    <para>
      Python's library can be found in the <literal moreinfo="none">/libs</literal> subdirectory
      of your Python directory. On Windows it is called pythonXY.lib where X.Y is
      your major Python version number.
    </para>
    <para>
      Additionally, Python's <literal moreinfo="none">/include</literal> subdirectory has to be added
      to your include path.
    </para>
    <para>
      In a Jamfile, all the above boils down to:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">projectroot c:\projects\embedded_program ; # location of the program

# bring in the rules for python
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;

exe embedded_program # name of the executable
  : #sources
     embedded_program.cpp
  : # requirements
     &lt;find-library&gt;boost_python &lt;library-path&gt;c:\boost\libs\python
  $(PYTHON_PROPERTIES)
    &lt;library-path&gt;$(PYTHON_LIB_PATH)
    &lt;find-library&gt;$(PYTHON_EMBEDDED_LIBRARY) ;
</programlisting>
    <bridgehead renderas="sect2" id="tutorial.embedding.h1">
      <phrase id="tutorial.embedding.getting_started"/><link linkend="tutorial.embedding.getting_started">Getting
      started</link>
    </bridgehead>
    <para>
      Being able to build is nice, but there is nothing to build yet. Embedding the
      Python interpreter into one of your C++ programs requires these 4 steps:
    </para>
    <orderedlist inheritnum="ignore" continuation="restarts">
      <listitem>
        <simpara>
          #include <literal moreinfo="none">&lt;boost/python.hpp&gt;</literal>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Call <ulink url="http://www.python.org/doc/current/api/initialization.html#l2h-652">Py_Initialize</ulink>()
          to start the interpreter and create the <literal moreinfo="none">__main__</literal> module.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Call other Python C API routines to use the interpreter.
        </simpara>
      </listitem>
    </orderedlist>
    <note>
      <para>
        <emphasis role="bold">Note that at this time you must not call <ulink url="http://www.python.org/doc/current/api/initialization.html#l2h-656">Py_Finalize</ulink>()
        to stop the interpreter. This may be fixed in a future version of boost.python.</emphasis>
      </para>
    </note>
    <para>
      (Of course, there can be other C++ code between all of these steps.)
    </para>
    <blockquote>
      <para>
        <emphasis><emphasis role="bold">Now that we can embed the interpreter in
        our programs, lets see how to put it to use...</emphasis></emphasis>
      </para>
    </blockquote>
    <section id="tutorial.embedding.using_the_interpreter">
      <title><link linkend="tutorial.embedding.using_the_interpreter">Using the interpreter</link></title>
      <para>
        As you probably already know, objects in Python are reference-counted. Naturally,
        the <literal moreinfo="none">PyObject</literal>s of the Python C API are also reference-counted.
        There is a difference however. While the reference-counting is fully automatic
        in Python, the Python C API requires you to do it <ulink url="http://www.python.org/doc/current/c-api/refcounting.html">by
        hand</ulink>. This is messy and especially hard to get right in the presence
        of C++ exceptions. Fortunately Boost.Python provides the <ulink url="../reference/utility_and_infrastructure/boost_python_handle_hpp.html#utility_and_infrastructure.boost_python_handle_hpp.class_template_handle">handle</ulink>
        and <ulink url="../reference/object_wrappers/boost_python_object_hpp.html#object_wrappers.boost_python_object_hpp.class_object">object</ulink>
        class templates to automate the process.
      </para>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h0">
        <phrase id="tutorial.embedding.using_the_interpreter.running_python_code"/><link linkend="tutorial.embedding.using_the_interpreter.running_python_code">Running
        Python code</link>
      </bridgehead>
      <para>
        Boost.python provides three related functions to run Python code from C++.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">expression</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">code</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">exec_file</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">filename</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">globals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">(),</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">locals</phrase> <phrase role="special">=</phrase> <phrase role="identifier">object</phrase><phrase role="special">())</phrase>
</programlisting>
      <para>
        eval evaluates the given expression and returns the resulting value. exec
        executes the given code (typically a set of statements) returning the result,
        and exec_file executes the code contained in the given file.
      </para>
      <para>
        The <literal moreinfo="none">globals</literal> and <literal moreinfo="none">locals</literal> parameters are
        Python dictionaries containing the globals and locals of the context in which
        to run the code. For most intents and purposes you can use the namespace
        dictionary of the <literal moreinfo="none">__main__</literal> module for both parameters.
      </para>
      <para>
        Boost.python provides a function to import a module:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase> <phrase role="identifier">name</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        import imports a python module (potentially loading it into the running process
        first), and returns it.
      </para>
      <para>
        Let's import the <literal moreinfo="none">__main__</literal> module and run some Python code
        in its namespace:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">main_module</phrase> <phrase role="special">=</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="string">"__main__"</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">main_namespace</phrase> <phrase role="special">=</phrase> <phrase role="identifier">main_module</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"__dict__"</phrase><phrase role="special">);</phrase>

<phrase role="identifier">object</phrase> <phrase role="identifier">ignored</phrase> <phrase role="special">=</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="string">"hello = file('hello.txt', 'w')\n"</phrase>
                      <phrase role="string">"hello.write('Hello world!')\n"</phrase>
                      <phrase role="string">"hello.close()"</phrase><phrase role="special">,</phrase>
                      <phrase role="identifier">main_namespace</phrase><phrase role="special">);</phrase>
</programlisting>
      <para>
        This should create a file called 'hello.txt' in the current directory containing
        a phrase that is well-known in programming circles.
      </para>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h1">
        <phrase id="tutorial.embedding.using_the_interpreter.manipulating_python_objects"/><link linkend="tutorial.embedding.using_the_interpreter.manipulating_python_objects">Manipulating
        Python objects</link>
      </bridgehead>
      <para>
        Often we'd like to have a class to manipulate Python objects. But we have
        already seen such a class above, and in the <link linkend="tutorial.object">previous
        section</link>: the aptly named <literal moreinfo="none">object</literal> class and its derivatives.
        We've already seen that they can be constructed from a <literal moreinfo="none">handle</literal>.
        The following examples should further illustrate this fact:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">main_module</phrase> <phrase role="special">=</phrase> <phrase role="identifier">import</phrase><phrase role="special">(</phrase><phrase role="string">"__main__"</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">main_namespace</phrase> <phrase role="special">=</phrase> <phrase role="identifier">main_module</phrase><phrase role="special">.</phrase><phrase role="identifier">attr</phrase><phrase role="special">(</phrase><phrase role="string">"__dict__"</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">ignored</phrase> <phrase role="special">=</phrase> <phrase role="identifier">exec</phrase><phrase role="special">(</phrase><phrase role="string">"result = 5 ** 2"</phrase><phrase role="special">,</phrase> <phrase role="identifier">main_namespace</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">five_squared</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">main_namespace</phrase><phrase role="special">[</phrase><phrase role="string">"result"</phrase><phrase role="special">]);</phrase>
</programlisting>
      <para>
        Here we create a dictionary object for the <literal moreinfo="none">__main__</literal> module's
        namespace. Then we assign 5 squared to the result variable and read this
        variable from the dictionary. Another way to achieve the same result is to
        use eval instead, which returns the result directly:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="string">"5 ** 2"</phrase><phrase role="special">);</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">five_squared</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">result</phrase><phrase role="special">);</phrase>
</programlisting>
      <bridgehead renderas="sect2" id="tutorial.embedding.using_the_interpreter.h2">
        <phrase id="tutorial.embedding.using_the_interpreter.exception_handling"/><link linkend="tutorial.embedding.using_the_interpreter.exception_handling">Exception
        handling</link>
      </bridgehead>
      <para>
        If an exception occurs in the evaluation of the python expression, <ulink url="../reference/high_level_components/boost_python_errors_hpp.html#high_level_components.boost_python_errors_hpp.class_error_already_set">error_already_set</ulink>
        is thrown:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">try</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">object</phrase> <phrase role="identifier">result</phrase> <phrase role="special">=</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="string">"5/0"</phrase><phrase role="special">);</phrase>
    <phrase role="comment">// execution will never get here:</phrase>
    <phrase role="keyword">int</phrase> <phrase role="identifier">five_divided_by_zero</phrase> <phrase role="special">=</phrase> <phrase role="identifier">extract</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">result</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
<phrase role="keyword">catch</phrase><phrase role="special">(</phrase><phrase role="identifier">error_already_set</phrase> <phrase role="keyword">const</phrase> <phrase role="special">&amp;)</phrase>
<phrase role="special">{</phrase>
    <phrase role="comment">// handle the exception in some way</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        The <literal moreinfo="none">error_already_set</literal> exception class doesn't carry any
        information in itself. To find out more about the Python exception that occurred,
        you need to use the <ulink url="http://www.python.org/doc/api/exceptionHandling.html">exception
        handling functions</ulink> of the Python C API in your catch-statement. This
        can be as simple as calling <ulink url="http://www.python.org/doc/api/exceptionHandling.html#l2h-70">PyErr_Print()</ulink>
        to print the exception's traceback to the console, or comparing the type
        of the exception with those of the <ulink url="http://www.python.org/doc/api/standardExceptions.html">standard
        exceptions</ulink>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">catch</phrase><phrase role="special">(</phrase><phrase role="identifier">error_already_set</phrase> <phrase role="keyword">const</phrase> <phrase role="special">&amp;)</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">PyErr_ExceptionMatches</phrase><phrase role="special">(</phrase><phrase role="identifier">PyExc_ZeroDivisionError</phrase><phrase role="special">))</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">// handle ZeroDivisionError specially</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">else</phrase>
    <phrase role="special">{</phrase>
        <phrase role="comment">// print all other errors to stderr</phrase>
        <phrase role="identifier">PyErr_Print</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        (To retrieve even more information from the exception you can use some of
        the other exception handling functions listed <ulink url="http://www.python.org/doc/api/exceptionHandling.html">here</ulink>.)
      </para>
    </section>
  </section>
  <section id="tutorial.iterators">
    <title><link linkend="tutorial.iterators">Iterators</link></title>
    <para>
      In C++, and STL in particular, we see iterators everywhere. Python also has
      iterators, but these are two very different beasts.
    </para>
    <para>
      <emphasis role="bold">C++ iterators:</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          C++ has 5 type categories (random-access, bidirectional, forward, input,
          output)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          There are 2 Operation categories: reposition, access
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          A pair of iterators is needed to represent a (first/last) range.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      <emphasis role="bold">Python Iterators:</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          1 category (forward)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          1 operation category (next())
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          Raises StopIteration exception at end
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      The typical Python iteration protocol: <literal moreinfo="none"><emphasis role="bold">for y
      in x...</emphasis></literal> is as follows:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">iter</phrase> <phrase role="special">=</phrase> <phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">__iter__</phrase><phrase role="special">()</phrase>         <phrase role="comment"># get iterator</phrase>
<phrase role="keyword">try</phrase><phrase role="special">:</phrase>
    <phrase role="keyword">while</phrase> <phrase role="number">1</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">y</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iter</phrase><phrase role="special">.</phrase><phrase role="identifier">next</phrase><phrase role="special">()</phrase>         <phrase role="comment"># get each item</phrase>
    <phrase role="special">...</phrase>                     <phrase role="comment"># process y</phrase>
<phrase role="keyword">except</phrase> <phrase role="identifier">StopIteration</phrase><phrase role="special">:</phrase> <phrase role="keyword">pass</phrase>  <phrase role="comment"># iterator exhausted</phrase>
</programlisting>
    <para>
      Boost.Python provides some mechanisms to make C++ iterators play along nicely
      as Python iterators. What we need to do is to produce appropriate <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">__iter__</phrase></computeroutput> function from C++ iterators that
      is compatible with the Python iteration protocol. For example:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">object</phrase> <phrase role="identifier">get_iterator</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;();</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">iter</phrase> <phrase role="special">=</phrase> <phrase role="identifier">get_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier">v</phrase><phrase role="special">);</phrase>
<phrase role="identifier">object</phrase> <phrase role="identifier">first</phrase> <phrase role="special">=</phrase> <phrase role="identifier">iter</phrase><phrase role="special">.</phrase><phrase role="identifier">next</phrase><phrase role="special">();</phrase>
</programlisting>
    <para>
      Or for use in class_&lt;&gt;:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"__iter__"</phrase><phrase role="special">,</phrase> <phrase role="identifier">iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;())</phrase>
</programlisting>
    <para>
      <emphasis role="bold">range</emphasis>
    </para>
    <para>
      We can create a Python savvy iterator using the range function:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          range(start, finish)
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          range&lt;Policies,Target&gt;(start, finish)
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      Here, start/finish may be one of:
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          member data pointers
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          member function pointers
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          adaptable function object (use Target parameter)
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      <emphasis role="bold">iterator</emphasis>
    </para>
    <itemizedlist>
      <listitem>
        <simpara>
          iterator&lt;T, Policies&gt;()
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      Given a container <literal moreinfo="none">T</literal>, iterator is a shortcut that simply
      calls <literal moreinfo="none">range</literal> with &amp;T::begin, &amp;T::end.
    </para>
    <para>
      Let's put this into action... Here's an example from some hypothetical bogon
      Particle accelerator code:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">f</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Field</phrase><phrase role="special">()</phrase>
<phrase role="keyword">for</phrase> <phrase role="identifier">x</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">pions</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">smash</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">)</phrase>
<phrase role="keyword">for</phrase> <phrase role="identifier">y</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">f</phrase><phrase role="special">.</phrase><phrase role="identifier">bogons</phrase><phrase role="special">:</phrase>
    <phrase role="identifier">count</phrase><phrase role="special">(</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase>
</programlisting>
    <para>
      Now, our C++ Wrapper:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">F</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"Field"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">property</phrase><phrase role="special">(</phrase><phrase role="string">"pions"</phrase><phrase role="special">,</phrase> <phrase role="identifier">range</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">p_begin</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">p_end</phrase><phrase role="special">))</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">property</phrase><phrase role="special">(</phrase><phrase role="string">"bogons"</phrase><phrase role="special">,</phrase> <phrase role="identifier">range</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">b_begin</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">F</phrase><phrase role="special">::</phrase><phrase role="identifier">b_end</phrase><phrase role="special">));</phrase>
</programlisting>
    <para>
      <emphasis role="bold">stl_input_iterator</emphasis>
    </para>
    <para>
      So far, we have seen how to expose C++ iterators and ranges to Python. Sometimes
      we wish to go the other way, though: we'd like to pass a Python sequence to
      an STL algorithm or use it to initialize an STL container. We need to make
      a Python iterator look like an STL iterator. For that, we use <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">stl_input_iterator</phrase><phrase role="special">&lt;&gt;</phrase></computeroutput>.
      Consider how we might implement a function that exposes <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">assign</phrase><phrase role="special">()</phrase></computeroutput> to Python:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">list_assign</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">l</phrase><phrase role="special">,</phrase> <phrase role="identifier">object</phrase> <phrase role="identifier">o</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="comment">// Turn a Python sequence into an STL input range</phrase>
    <phrase role="identifier">stl_input_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">begin</phrase><phrase role="special">(</phrase><phrase role="identifier">o</phrase><phrase role="special">),</phrase> <phrase role="identifier">end</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">l</phrase><phrase role="special">.</phrase><phrase role="identifier">assign</phrase><phrase role="special">(</phrase><phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">end</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">// Part of the wrapper for list&lt;int&gt;</phrase>
<phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">list</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;(</phrase><phrase role="string">"list_int"</phrase><phrase role="special">)</phrase>
    <phrase role="special">.</phrase><phrase role="identifier">def</phrase><phrase role="special">(</phrase><phrase role="string">"assign"</phrase><phrase role="special">,</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">list_assign</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;)</phrase>
    <phrase role="comment">// ...</phrase>
    <phrase role="special">;</phrase>
</programlisting>
    <para>
      Now in Python, we can assign any integer sequence to <computeroutput xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">list_int</phrase></computeroutput>
      objects:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="identifier">list_int</phrase><phrase role="special">();</phrase>
<phrase role="identifier">x</phrase><phrase role="special">.</phrase><phrase role="identifier">assign</phrase><phrase role="special">([</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase><phrase role="number">2</phrase><phrase role="special">,</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase><phrase role="number">4</phrase><phrase role="special">,</phrase><phrase role="number">5</phrase><phrase role="special">])</phrase>
</programlisting>
  </section>
  <section id="tutorial.exception">
    <title><link linkend="tutorial.exception">Exception Translation</link></title>
    <para>
      All C++ exceptions must be caught at the boundary with Python code. This boundary
      is the point where C++ meets Python. Boost.Python provides a default exception
      handler that translates selected standard exceptions, then gives up:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">raise</phrase> <phrase role="identifier">RuntimeError</phrase><phrase role="special">,</phrase> <phrase role="string">'unidentifiable C++ Exception'</phrase>
</programlisting>
    <para>
      Users may provide custom translation. Here's an example:
    </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">struct</phrase> <phrase role="identifier">PodBayDoorException</phrase><phrase role="special">;</phrase>
<phrase role="identifier">void</phrase> <phrase role="identifier">translator</phrase><phrase role="special">(</phrase><phrase role="identifier">PodBayDoorException</phrase> <phrase role="identifier">const</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">x</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="identifier">PyErr_SetString</phrase><phrase role="special">(</phrase><phrase role="identifier">PyExc_UserWarning</phrase><phrase role="special">,</phrase> <phrase role="string">"I'm sorry Dave..."</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">kubrick</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
     <phrase role="identifier">register_exception_translator</phrase><phrase role="special">&lt;</phrase>
          <phrase role="identifier">PodBayDoorException</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">translator</phrase><phrase role="special">);</phrase>
     <phrase role="special">...</phrase>
</programlisting>
  </section>
  <section id="tutorial.techniques">
    <title><link linkend="tutorial.techniques">General Techniques</link></title>
    <para>
      Here are presented some useful techniques that you can use while wrapping code
      with Boost.Python.
    </para>
    <section id="tutorial.techniques.creating_packages">
      <title><link linkend="tutorial.techniques.creating_packages">Creating Packages</link></title>
      <para>
        A Python package is a collection of modules that provide to the user a certain
        functionality. If you're not familiar on how to create packages, a good introduction
        to them is provided in the <ulink url="http://www.python.org/doc/current/tut/node8.html">Python
        Tutorial</ulink>.
      </para>
      <para>
        But we are wrapping C++ code, using Boost.Python. How can we provide a nice
        package interface to our users? To better explain some concepts, let's work
        with an example.
      </para>
      <para>
        We have a C++ library that works with sounds: reading and writing various
        formats, applying filters to the sound data, etc. It is named (conveniently)
        <literal moreinfo="none">sounds</literal>. Our library already has a neat C++ namespace hierarchy,
        like so:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">core</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">io</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">filters</phrase>
</programlisting>
      <para>
        We would like to present this same hierarchy to the Python user, allowing
        him to write code like this:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(...)</phrase> <phrase role="comment"># echo is a C++ function</phrase>
</programlisting>
      <para>
        The first step is to write the wrapping code. We have to export each module
        separately with Boost.Python, like this:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">core</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">core</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>

<phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">io</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">io</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">io</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>

<phrase role="special">/*</phrase> <phrase role="identifier">file</phrase> <phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">cpp</phrase> <phrase role="special">*/</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">filters</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">/*</phrase> <phrase role="identifier">export</phrase> <phrase role="identifier">everything</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">::</phrase><phrase role="identifier">filters</phrase> <phrase role="identifier">namespace</phrase> <phrase role="special">*/</phrase>
    <phrase role="special">...</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Compiling these files will generate the following Python extensions: <literal moreinfo="none">core.pyd</literal>,
        <literal moreinfo="none">io.pyd</literal> and <literal moreinfo="none">filters.pyd</literal>.
      </para>
      <note>
        <para>
          The extension <literal moreinfo="none">.pyd</literal> is used for python extension modules,
          which are just shared libraries. Using the default for your system, like
          <literal moreinfo="none">.so</literal> for Unix and <literal moreinfo="none">.dll</literal> for Windows,
          works just as well.
        </para>
      </note>
      <para>
        Now, we create this directory structure for our Python package:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">sounds/
    __init__.py
    core.pyd
    filters.pyd
    io.pyd
</programlisting>
      <para>
        The file <literal moreinfo="none">__init__.py</literal> is what tells Python that the directory
        <literal moreinfo="none">sounds/</literal> is actually a Python package. It can be a empty
        file, but can also perform some magic, that will be shown later.
      </para>
      <para>
        Now our package is ready. All the user has to do is put <literal moreinfo="none">sounds</literal>
        into his <ulink url="http://www.python.org/doc/current/tut/node8.html#SECTION008110000000000000000">PYTHONPATH</ulink>
        and fire up the interpreter:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">io</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sound</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">io</phrase><phrase role="special">.</phrase><phrase role="identifier">open</phrase><phrase role="special">(</phrase><phrase role="string">'file.mp3'</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">new_sound</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">,</phrase> <phrase role="number">1.0</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        Nice heh?
      </para>
      <para>
        This is the simplest way to create hierarchies of packages, but it is not
        very flexible. What if we want to add a <emphasis>pure</emphasis> Python
        function to the filters package, for instance, one that applies 3 filters
        in a sound object at once? Sure, you can do this in C++ and export it, but
        why not do so in Python? You don't have to recompile the extension modules,
        plus it will be easier to write it.
      </para>
      <para>
        If we want this flexibility, we will have to complicate our package hierarchy
        a little. First, we will have to change the name of the extension modules:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">/* file core.cpp */</phrase>
<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_core</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="special">...</phrase>
    <phrase role="comment">/* export everything in the sounds::core namespace */</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Note that we added an underscore to the module name. The filename will have
        to be changed to <literal moreinfo="none">_core.pyd</literal> as well, and we do the same
        to the other extension modules. Now, we change our package hierarchy like
        so:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude">sounds/
    __init__.py
    core/
        __init__.py
        _core.pyd
    filters/
        __init__.py
        _filters.pyd
    io/
        __init__.py
        _io.pyd
</programlisting>
      <para>
        Note that we created a directory for each extension module, and added a __init__.py
        to each one. But if we leave it that way, the user will have to access the
        functions in the core module with this syntax:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">_core</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">core</phrase><phrase role="special">.</phrase><phrase role="identifier">_core</phrase><phrase role="special">.</phrase><phrase role="identifier">foo</phrase><phrase role="special">(...)</phrase>
</programlisting>
      <para>
        which is not what we want. But here enters the <literal moreinfo="none">__init__.py</literal>
        magic: everything that is brought to the <literal moreinfo="none">__init__.py</literal> namespace
        can be accessed directly by the user. So, all we have to do is bring the
        entire namespace from <literal moreinfo="none">_core.pyd</literal> to <literal moreinfo="none">core/__init__.py</literal>.
        So add this line of code to <literal moreinfo="none">sounds/core/__init__.py</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">from</phrase> <phrase role="identifier">_core</phrase> <phrase role="keyword">import</phrase> <phrase role="special">*</phrase>
</programlisting>
      <para>
        We do the same for the other packages. Now the user accesses the functions
        and classes in the extension modules like before:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(...)</phrase>
</programlisting>
      <para>
        with the additional benefit that we can easily add pure Python functions
        to any module, in a way that the user can't tell the difference between a
        C++ function and a Python function. Let's add a <emphasis>pure</emphasis>
        Python function, <literal moreinfo="none">echo_noise</literal>, to the <literal moreinfo="none">filters</literal>
        package. This function applies both the <literal moreinfo="none">echo</literal> and <literal moreinfo="none">noise</literal>
        filters in sequence in the given <literal moreinfo="none">sound</literal> object. We create
        a file named <literal moreinfo="none">sounds/filters/echo_noise.py</literal> and code our
        function:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">import</phrase> <phrase role="identifier">_filters</phrase>
<phrase role="keyword">def</phrase> <phrase role="identifier">echo_noise</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">):</phrase>
    <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">_filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">)</phrase>
    <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">_filters</phrase><phrase role="special">.</phrase><phrase role="identifier">noise</phrase><phrase role="special">(</phrase><phrase role="identifier">sound</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">s</phrase>
</programlisting>
      <para>
        Next, we add this line to <literal moreinfo="none">sounds/filters/__init__.py</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">from</phrase> <phrase role="identifier">echo_noise</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">echo_noise</phrase>
</programlisting>
      <para>
        And that's it. The user now accesses this function like any other function
        from the <literal moreinfo="none">filters</literal> package:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">import</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">sounds</phrase><phrase role="special">.</phrase><phrase role="identifier">filters</phrase><phrase role="special">.</phrase><phrase role="identifier">echo_noise</phrase><phrase role="special">(...)</phrase>
</programlisting>
    </section>
    <section id="tutorial.techniques.extending_wrapped_objects_in_pyt">
      <title><link linkend="tutorial.techniques.extending_wrapped_objects_in_pyt">Extending
      Wrapped Objects in Python</link></title>
      <para>
        Thanks to Python's flexibility, you can easily add new methods to a class,
        even after it was already created:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">class</phrase> <phrase role="identifier">C</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase><phrase role="special">):</phrase> <phrase role="keyword">pass</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="comment"># a regular function</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">def</phrase> <phrase role="identifier">C_str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase> <phrase role="keyword">return</phrase> <phrase role="string">'A C instance!'</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="comment"># now we turn it in a member function</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">C</phrase><phrase role="special">.</phrase><phrase role="identifier">__str__</phrase> <phrase role="special">=</phrase> <phrase role="identifier">C_str</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="identifier">C</phrase><phrase role="special">()</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">c</phrase>
<phrase role="identifier">A</phrase> <phrase role="identifier">C</phrase> <phrase role="identifier">instance</phrase><phrase role="special">!</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">C_str</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase>
<phrase role="identifier">A</phrase> <phrase role="identifier">C</phrase> <phrase role="identifier">instance</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        Yes, Python rox. <inlinemediaobject><imageobject><imagedata fileref="../images/smiley.png"/></imageobject></inlinemediaobject>
      </para>
      <para>
        We can do the same with classes that were wrapped with Boost.Python. Suppose
        we have a class <literal moreinfo="none">point</literal> in C++:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">class</phrase> <phrase role="identifier">point</phrase> <phrase role="special">{...};</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"point"</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        If we are using the technique from the previous session, <link linkend="tutorial.techniques.creating_packages">Creating
        Packages</link>, we can code directly into <literal moreinfo="none">geom/__init__.py</literal>:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">from</phrase> <phrase role="identifier">_geom</phrase> <phrase role="keyword">import</phrase> <phrase role="special">*</phrase>

<phrase role="comment"># a regular function</phrase>
<phrase role="keyword">def</phrase> <phrase role="identifier">point_str</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">str</phrase><phrase role="special">((</phrase><phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">y</phrase><phrase role="special">))</phrase>

<phrase role="comment"># now we turn it into a member function</phrase>
<phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">__str__</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point_str</phrase>
</programlisting>
      <para>
        <emphasis role="bold">All</emphasis> point instances created from C++ will
        also have this member function! This technique has several advantages:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Cut down compile times to zero for these additional functions
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Reduce the memory footprint to virtually zero
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Minimize the need to recompile
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Rapid prototyping (you can move the code to C++ if required without changing
            the interface)
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        You can even add a little syntactic sugar with the use of metaclasses. Let's
        create a special metaclass that "injects" methods in other classes.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment"># The one Boost.Python uses for all wrapped classes.</phrase>
<phrase role="comment"># You can use here any class exported by Boost instead of "point"</phrase>
<phrase role="identifier">BoostPythonMetaclass</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">__class__</phrase>

<phrase role="keyword">class</phrase> <phrase role="identifier">injector</phrase><phrase role="special">(</phrase><phrase role="identifier">object</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">__metaclass__</phrase><phrase role="special">(</phrase><phrase role="identifier">BoostPythonMetaclass</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">def</phrase> <phrase role="identifier">__init__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">,</phrase> <phrase role="identifier">dict</phrase><phrase role="special">):</phrase>
            <phrase role="keyword">for</phrase> <phrase role="identifier">b</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">bases</phrase><phrase role="special">:</phrase>
                <phrase role="keyword">if</phrase> <phrase role="identifier">type</phrase><phrase role="special">(</phrase><phrase role="identifier">b</phrase><phrase role="special">)</phrase> <phrase role="keyword">not</phrase> <phrase role="keyword">in</phrase> <phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">type</phrase><phrase role="special">):</phrase>
                    <phrase role="keyword">for</phrase> <phrase role="identifier">k</phrase><phrase role="special">,</phrase><phrase role="identifier">v</phrase> <phrase role="keyword">in</phrase> <phrase role="identifier">dict</phrase><phrase role="special">.</phrase><phrase role="identifier">items</phrase><phrase role="special">():</phrase>
                        <phrase role="identifier">setattr</phrase><phrase role="special">(</phrase><phrase role="identifier">b</phrase><phrase role="special">,</phrase><phrase role="identifier">k</phrase><phrase role="special">,</phrase><phrase role="identifier">v</phrase><phrase role="special">)</phrase>
            <phrase role="keyword">return</phrase> <phrase role="identifier">type</phrase><phrase role="special">.</phrase><phrase role="identifier">__init__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">,</phrase> <phrase role="identifier">name</phrase><phrase role="special">,</phrase> <phrase role="identifier">bases</phrase><phrase role="special">,</phrase> <phrase role="identifier">dict</phrase><phrase role="special">)</phrase>

<phrase role="comment"># inject some methods in the point foo</phrase>
<phrase role="keyword">class</phrase> <phrase role="identifier">more_point</phrase><phrase role="special">(</phrase><phrase role="identifier">injector</phrase><phrase role="special">,</phrase> <phrase role="identifier">point</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">def</phrase> <phrase role="identifier">__repr__</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">return</phrase> <phrase role="string">'Point(x=%s, y=%s)'</phrase> <phrase role="special">%</phrase> <phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">self</phrase><phrase role="special">.</phrase><phrase role="identifier">y</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">def</phrase> <phrase role="identifier">foo</phrase><phrase role="special">(</phrase><phrase role="identifier">self</phrase><phrase role="special">):</phrase>
        <phrase role="keyword">print</phrase> <phrase role="string">'foo!'</phrase>
</programlisting>
      <para>
        Now let's see how it got:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="keyword">print</phrase> <phrase role="identifier">point</phrase><phrase role="special">()</phrase>
<phrase role="identifier">Point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">=</phrase><phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">=</phrase><phrase role="number">10</phrase><phrase role="special">)</phrase>
<phrase role="special">&gt;&gt;&gt;</phrase> <phrase role="identifier">point</phrase><phrase role="special">().</phrase><phrase role="identifier">foo</phrase><phrase role="special">()</phrase>
<phrase role="identifier">foo</phrase><phrase role="special">!</phrase>
</programlisting>
      <para>
        Another useful idea is to replace constructors with factory functions:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="identifier">_point</phrase> <phrase role="special">=</phrase> <phrase role="identifier">point</phrase>

<phrase role="keyword">def</phrase> <phrase role="identifier">point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">):</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">_point</phrase><phrase role="special">(</phrase><phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
</programlisting>
      <para>
        In this simple case there is not much gained, but for constructurs with many
        overloads and/or arguments this is often a great simplification, again with
        virtually zero memory footprint and zero compile-time overhead for the keyword
        support.
      </para>
    </section>
    <section id="tutorial.techniques.reducing_compiling_time">
      <title><link linkend="tutorial.techniques.reducing_compiling_time">Reducing
      Compiling Time</link></title>
      <para>
        If you have ever exported a lot of classes, you know that it takes quite
        a good time to compile the Boost.Python wrappers. Plus the memory consumption
        can easily become too high. If this is causing you problems, you can split
        the class_ definitions in multiple files:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="comment">/* file point.cpp */</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">export_point</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"point"</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>

<phrase role="comment">/* file triangle.cpp */</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">void</phrase> <phrase role="identifier">export_triangle</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"triangle"</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Now you create a file <literal moreinfo="none">main.cpp</literal>, which contains the <literal moreinfo="none">BOOST_PYTHON_MODULE</literal>
        macro, and call the various export functions inside it.
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="keyword">void</phrase> <phrase role="identifier">export_point</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">export_triangle</phrase><phrase role="special">();</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">export_point</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">export_triangle</phrase><phrase role="special">();</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        Compiling and linking together all this files produces the same result as
        the usual approach:
      </para>
<programlisting xmlns:xi="http://www.w3.org/2001/XInclude"><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">python</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>

<phrase role="identifier">BOOST_PYTHON_MODULE</phrase><phrase role="special">(</phrase><phrase role="identifier">_geom</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">point</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"point"</phrase><phrase role="special">)...;</phrase>
    <phrase role="identifier">class_</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">triangle</phrase><phrase role="special">&gt;(</phrase><phrase role="string">"triangle"</phrase><phrase role="special">)...;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      <para>
        but the memory is kept under control.
      </para>
      <para>
        This method is recommended too if you are developing the C++ library and
        exporting it to Python at the same time: changes in a class will only demand
        the compilation of a single cpp, instead of the entire wrapper code.
      </para>
      <note>
        <para>
          This method is useful too if you are getting the error message <emphasis>"fatal
          error C1204:Compiler limit:internal structure overflow"</emphasis>
          when compiling a large source file, as explained in the <ulink url="../faq/fatal_error_c1204_compiler_limit.html">FAQ</ulink>.
        </para>
      </note>
    </section>
  </section>
</article>
